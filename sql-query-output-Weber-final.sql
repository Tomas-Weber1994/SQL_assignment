-- Assignment in SQLLite. Recommended to go to https://sqliteonline.com/ and past following commands ---

--- Solution / Queries under entry commands --- 

CREATE TABLE customers (
    customer_id int,
    last_name varchar(50),
    first_name varchar(50),
	referred_by_id varchar(50));
    
INSERT INTO customers (customer_id,first_name,last_name, referred_by_id)
	VALUES (1,'John','White',''),
		(2,'Sarah','Green',''),
        (3,'George','Black',''),
		(4,'Mark','Koon',''),
		(5,'Tom','Gone',''),
        (6,'Ezra','Beck',''),
		(7,'Jan','Wick',2),
		(8,'Petr','Lame',''),
        (9,'Lucy','Can',''),
		(10,'Karl','Opel',1),
		(11,'Ron','Varon',10),
        (12,'Harry','Bond',''),
		(13,'Paul','Kong',''),
		(14,'Shaun','King',3),
        (15,'Elisabeth','Yellow','');
        
CREATE TABLE contacts (
    customer_id int,
    address varchar(255),
    city varchar(255),
  	phone_number varchar(20),
  	email VARCHAR(255));
    
    
INSERT INTO contacts (customer_id,address,city,phone_number,email)
	VALUES (1,'3525  Fort Street','COLUMBUS','2532326578','JW@email.com'),
		(2,'3924  Cooks Mine Road','Albuquerque','5057657670','SarahG@email.com'),
        (3,'925  College Street','Atlanta','4043278560','Georgie@email.com');

CREATE TABLE orders (
    customer_id int,
    order_id INT,
    item varchar(50),
  	order_value DECIMAL(12,2),
  	order_currency varchar(3),
  	order_date TIMESTAMP);
 
INSERT INTO orders (customer_id,order_id,item,order_value,order_currency,order_date)
	VALUES(1,1,'HDMI cable',3.25,'EUR','2020-01-21 14:50:04'),
    	(2,2,'Keyboard','15.99','EUR','2020-01-21 17:50:04'),
        (3,3,'Charger','9.99','EUR','2020-01-22 18:00:07'),
        (3,3,'Charger','9.99','EUR','2020-01-22 18:00:07'),
        (3,4,'Phone','225.89','EUR','2020-01-22 19:10:56'),
        (2,5,'Camera','199.99','EUR','2020-01-23 07:50:44'),
        (1,6,'Speakers','75.50','EUR','2020-01-23 08:40:00'),
        (1,6,'Speakers','75.50','EUR','2020-01-23 08:40:00'),
        (2,7,'Mouse','22.19','EUR','2020-01-23 09:20:59');    
    
    
-- TASK 1 --
-- Write query which will show those customers with contacts and with orders (all columns) ---     
       
SELECT c.*, c2.address, c2.city, c2.phone_number, c2.email, o.order_id, o.item, o.order_value, o.order_currency, o.order_date 
FROM customers c
JOIN contacts c2
	ON c.customer_id = c2.customer_id
JOIN (SELECT DISTINCT * FROM orders) o /* Filtering out duplicate orders */
	ON c2.customer_id = o.customer_id;

/* 
Query above returns more orders for listed customers, 
so maybe it would be for us valuable to find out how much each customer (with contact information) spends in sum (or in average):
*/

SELECT 
	c.customer_id, 
	c.last_name, 
	c.first_name, 
	c2.address, 
	c2.city, 
	c2.phone_number, 
	c2.email, 
	ROUND(SUM(o.order_value),2) AS orders_in_total_EUR, 
	ROUND(AVG(o.order_value),2) AS average_order_value_EUR
FROM customers c
JOIN contacts c2
	ON c.customer_id = c2.customer_id
JOIN (SELECT DISTINCT * FROM orders) o /* Filtering out duplicate orders */
	ON c2.customer_id = o.customer_id
GROUP BY c.customer_id, c.last_name, c.first_name, c2.address, c2.city, c2.phone_number, c2.email
ORDER BY SUM(o.order_value) DESC;


--- TASK 2 ---
--- There is suspision that some orders were wrongly inserted more times. Check if there are any duplicated orders. If so, return unique duplicates with the following details: ---
-- first name, last name, email, order id and item ---


WITH t1 AS ( 
	SELECT 
		customer_id, 
		order_id, 
		item, 
		ROW_NUMBER() OVER (PARTITION BY order_id) AS num_of_records /* Alternative: COUNT(1) FROM orders o GROUP BY <columns above>, HAVING COUNT(1) > 1 */
	FROM orders
	)
SELECT
	c.first_name,
	c.last_name,
	c2.email, 
	t1.order_id, 
	t1.item, 
	num_of_records
FROM t1
JOIN customers c 
	ON t1.customer_id = c.customer_id
JOIN contacts c2
	ON c.customer_id = c2.customer_id
WHERE num_of_records > 1;
	
	
--- TASK 3 ---	
-- As you found out, there are some duplicated order which are incorrect, adjust query so it does following:
-- Show first name, last name, email, order id and item
-- Does not show duplicates
-- Order result by customer last name

WITH t1 AS ( 
	SELECT 
		customer_id, 
		order_id, 
		item, 
		ROW_NUMBER() OVER (PARTITION BY order_id) AS num_of_records /* Alternative: COUNT(1) FROM orders o GROUP BY <variables above>, HAVING COUNT(1) > 1 */
	FROM orders
	)
SELECT
	c.first_name,
	c.last_name,
	c2.email, 
	t1.order_id, 
	t1.item
FROM t1
JOIN customers c 
	ON t1.customer_id = c.customer_id
JOIN contacts c2
	ON c.customer_id = c2.customer_id
WHERE num_of_records = 1
ORDER BY c.last_name;

/* Good solution how to avoid duplicate orders would be on my openion to set an integrity constraint 
 * on the beginning when creating the dataset - in this situation order_id should be the primary key, 
 * also there is a possibility to set an auto-increment --> order_id would be generated by the database system
*/

--- TASK 4 ---
--- Our company distinguishes orders to sizes by value like so:
--- order with value less or equal to 25 euro is marked as SMALL
--- order with value more than 25 euro but less or equal to 100 euro is marked as MEDIUM
--- order with value more than 100 euro is marked as BIG
--- Write query which shows only three columns: full_name (first and last name divided by space), order_id and order_size
--- Make sure the duplicated values are not shown
--- Sort by order ID (ascending)

WITH t1 AS (
	SELECT 
		customer_id, 
		order_id, 
		order_value, 
		CASE 
			WHEN order_value <= 25 THEN 'SMALL'
			WHEN order_value  > 25 AND order_value <= 100 THEN 'MEDIUM'
			WHEN order_value > 100 THEN 'BIG'
		END AS order_size
	FROM orders
	)
SELECT DISTINCT 
    c.first_name || ' ' || c.last_name AS full_name, 
	t1.order_id, 
	t1.order_size 
FROM t1
JOIN customers c
	ON t1.customer_id = c.customer_id
ORDER BY t1.order_id;


--- TASK 5 ---
-- Show all items from orders table which containt in their name 'ea' or start with 'Key'

SELECT item
FROM orders o
WHERE 
	item LIKE '%ea%' OR 
	item LIKE 'Key%';


-- TASK 6 --
-- Please find out if some customer was referred by already existing customer
-- Return results in following format "Customer Last name Customer First name" "Last name First name of customer who recomended the new customer"
-- Sort/Order by customer last name (ascending)

WITH t1 AS (
	SELECT 
		customer_id, 
		last_name, 
		last_name || ' ' || first_name AS customer_name, 
		referred_by_id
	FROM customers
	WHERE referred_by_id != '' /* Instead of empty string value I would expect NULL */
	)
SELECT 
	t1.customer_name, 
	c.last_name || ' ' || c.first_name AS referred_by_customer_name
FROM t1
JOIN customers c
	ON t1.referred_by_id = c.customer_id
ORDER BY t1.last_name;
